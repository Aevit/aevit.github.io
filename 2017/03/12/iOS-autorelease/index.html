<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="iOS 自动释放池原理探究"/>




  <meta name="keywords" content="比特海, iOS, runtime, autorelease, Aevit" />










  <link rel="alternate" href="/atom.xml" title="Aevit">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.5.0" />



<link rel="canonical" href="http://aevit.xyz/2017/03/12/iOS-autorelease/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.5.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  
  <script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?27c09d216f39fb173da80070c4219fb8";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> iOS 自动释放池原理探究 - Aevit </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Aevit</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Aevit</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title-diu-helkyle">
        
          iOS 自动释放池原理探究
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-03-12
        </span>
        
          <div class="post-category">
            
              <a href="/categories/比特海/">比特海</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Clang"><span class="toc-text">Clang</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AutoreleasePoolPage"><span class="toc-text">AutoreleasePoolPage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#objc-autoreleasePoolPush"><span class="toc-text">objc_autoreleasePoolPush</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#objc-autoreleasePoolPop"><span class="toc-text">objc_autoreleasePoolPop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#push"><span class="toc-text">push</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pop"><span class="toc-text">pop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展"><span class="toc-text">扩展</span></a></li></ol></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章主要通过苹果开源的 <a href="https://opensource.apple.com/source/objc4/objc4-706/runtime/NSObject.mm.auto.html" target="_blank" rel="external">NSObject.mm</a>（注：写这文章时的日期是 2017.3.12，使用的版本是<code>objc4-706</code>，可能与以前的版本会稍有不同） 来对 <code>@autoreleasepool</code> 进行说明。</p>
<a id="more"></a>
<h2 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a>Clang</h2><p>首先我们还是 <code>Clang</code> 一下 <code>main.m</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>得到以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line">        return UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;AppDelegate&quot;), sel_registerName(&quot;class&quot;))));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，<code>@autoreleasepool</code> 被转换成了这一句代码：<br><code>__AtAutoreleasePool __autoreleasepool;</code></p>
<p>这个 <code>__AtAutoreleasePool</code> 是一个结构体，其中包含一个构造函数及一个析构函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct __AtAutoreleasePool &#123;</div><div class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</div><div class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</div><div class="line">  void * atautoreleasepoolobj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个结构体的构造函数会调用 <code>objc_autoreleasePoolPush()</code> 并返回一个 <code>atautoreleasepoolobj</code> 对象，并且其析构函数，会将 <code>atautoreleasepoolobj</code> 对象作为 <code>objc_autoreleasePoolPop()</code> 的入参。</p>
<p>这两个函数的实现如下，后面我们再详细解释这两个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void *objc_autoreleasePoolPush(void)</div><div class="line">&#123;</div><div class="line">    return AutoreleasePoolPage::push();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void objc_autoreleasePoolPop(void *ctxt)</div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage::pop(ctxt);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到分别是调用 <code>AutoreleasePoolPage</code> 的 <code>push</code> <code>pop</code> 这两个静态方法。</p>
<p>那么 <code>AutoreleasePoolPage</code> 是什么？</p>
<h2 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h2><p><code>NSObject.mm</code> 文件里有如下注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Autorelease pool implementation</div><div class="line">A thread&apos;s autorelease pool is a stack of pointers. </div><div class="line">Each pointer is either an object to release, or POOL_BOUNDARY which is </div><div class="line"> an autorelease pool boundary.</div><div class="line">A pool token is a pointer to the POOL_BOUNDARY for that pool. When </div><div class="line"> the pool is popped, every object hotter than the sentinel is released.</div><div class="line">The stack is divided into a doubly-linked list of pages. Pages are added </div><div class="line"> and deleted as necessary. </div><div class="line">Thread-local storage points to the hot page, where newly autoreleased </div><div class="line"> objects are stored.</div></pre></td></tr></table></figure>
<p>翻译如下：</p>
<ul>
<li>每个线程的 autorelease pool 是一个指针的堆栈；</li>
<li>每个指针不是指向一个需要 <code>release</code> 的对象，就是指向一个 <code>POOL_BOUNDARY</code>（哨兵对象，表示一个 autorelease pool 的边界）；</li>
<li>一个 pool token 指向这个 <code>POOL_BOUNDARY</code>（pool 的边界）。当这个 pool 被 pop 的时候，在这个哨兵对象后面添加的那些结点都会被 release；</li>
<li>这个堆栈（即 autorelease pool）是一个以 page 为结点的双向链表，这些 page 会在必要的时候增加或删除；</li>
<li>Thread-local storage（TLS，即线程局部存储）指向 hot page，这个 hot page 是指最新添加的 autorelease 对象所在的那个 page。</li>
</ul>
<p><strong>这里要注意，栈上只存指针（就是对象的地址），对象本身是存在堆上的，因为创建一个 OC 对象，最终都是要通过 alloc + init 的。</strong></p>
<blockquote>
<p>注：以前的哨兵对象叫 <code>POOL_SENTINEL</code>，现在叫 <code>POOL_BOUNDARY</code></p>
</blockquote>
<p>从 <code>NSObject.mm</code> 文件里摘抄这个类的成员变量部分代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class AutoreleasePoolPage </div><div class="line">&#123;</div><div class="line">    // EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is </div><div class="line">    // pushed and it has never contained any objects. This saves memory </div><div class="line">    // when the top level (i.e. libdispatch) pushes and pops pools but </div><div class="line">    // never uses them.</div><div class="line">#   define EMPTY_POOL_PLACEHOLDER ((id*)1)</div><div class="line"></div><div class="line">#   define POOL_BOUNDARY nil</div><div class="line">    static pthread_key_t const key = AUTORELEASE_POOL_KEY;</div><div class="line">    static uint8_t const SCRIBBLE = 0xA3;  // 0xA3A3A3A3 after releasing</div><div class="line">    static size_t const SIZE = </div><div class="line">#if PROTECT_AUTORELEASEPOOL</div><div class="line">        PAGE_MAX_SIZE;  // must be multiple of vm page size</div><div class="line">#else</div><div class="line">        PAGE_MAX_SIZE;  // size and alignment, power of 2</div><div class="line">#endif</div><div class="line">    static size_t const COUNT = SIZE / sizeof(id);</div><div class="line"></div><div class="line">    magic_t const magic;</div><div class="line">    id *next;</div><div class="line">    pthread_t const thread;</div><div class="line">    AutoreleasePoolPage * const parent;</div><div class="line">    AutoreleasePoolPage *child;</div><div class="line">    uint32_t const depth;</div><div class="line">    uint32_t hiwat;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>画个图看一下：</p>
<p><img src="http://file.arvit.xyz/a98396bd64d1610f4889c42d2b76e32e1489222777.jpeg" alt="image"></p>
<ul>
<li><code>magic</code> 用来校验 <code>AutoreleasePoolPage</code> 的结构是否完整;</li>
<li><code>next</code> 指向最新添加的 <code>autoreleased</code> 对象的下一个位置，初始化时指向 <code>begin()</code>;</li>
<li><code>thread</code> 指向当前线程;</li>
<li><code>parent</code> 指向父结点，第一个结点的 <code>parent</code> 值为 <code>nil</code>;</li>
<li><code>child</code> 指向子结点，最后一个结点的 <code>child</code> 值为 <code>nil</code>;</li>
<li><code>depth</code> 代表深度，从 <code>0</code> 开始，往后递增 <code>1</code>;</li>
<li><code>hiwat</code> 代表 <code>high water mark</code>，表示入栈最多时候的指针个数;</li>
</ul>
<p>由上面 <code>AutoreleasePoolPage</code> 类的定义里也可以看到，一个 <code>Page</code> 会开辟 <code>PAGE_MAX_SIZE</code> 的内存（以前的版本是 <code>4096 bytes</code>，现在可能会根据不同设备及系统分配不同的内存），除了 <code>AutoreleasePoolPage</code> 的成员变量所占空间（共 <code>56 bytes</code>），其余空间将会用来存储加入到自动释放池的对象。</p>
<p>初始的 <code>next == begin()</code>，新加入自动释放池的一个对象，会存放在当前 <code>next</code> 指向的位置，当对象存放完成后，<code>next</code> 指针会指向下一个为空的地址。<br>当 <code>next == end()</code> 时，表示当前 page 已经满了。</p>
<p>接下来让我们来详细说明自动释放池的原理。</p>
<hr>
<h2 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush"></a>objc_autoreleasePoolPush</h2><p>先上张图（红色部分表示 push 后会变化的东西），接着再详细说明其流程：</p>
<p><img src="http://file.arvit.xyz/dd6c093b0b87c86ed7e16c1fe6ad2f0d1489502563.png" alt="image"></p>
<p>上文已经提到，<code>objc_autoreleasePoolPush</code> 函数定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void *objc_autoreleasePoolPush(void)</div><div class="line">&#123;</div><div class="line">    return AutoreleasePoolPage::push();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>静态方法 push 的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static inline void *push() </div><div class="line">&#123;</div><div class="line">    id *dest;</div><div class="line">    if (DebugPoolAllocation) &#123;</div><div class="line">        // Each autorelease pool starts on a new pool page.</div><div class="line">        dest = autoreleaseNewPage(POOL_BOUNDARY);</div><div class="line">    &#125; else &#123;</div><div class="line">        dest = autoreleaseFast(POOL_BOUNDARY);</div><div class="line">    &#125;</div><div class="line">    assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</div><div class="line">    return dest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里会调用 <code>autoreleaseFast(POOL_BOUNDARY)</code> 操作，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static inline id *autoreleaseFast(id obj)</div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage *page = hotPage();</div><div class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</div><div class="line">        return page-&gt;add(obj);</div><div class="line">    &#125; else if (page) &#123;</div><div class="line">        return autoreleaseFullPage(obj, page);</div><div class="line">    &#125; else &#123;</div><div class="line">        return autoreleaseNoPage(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里分为三种情况：</p>
<ul>
<li>hotPage 存在并且还没满<ul>
<li>调用 <code>page-&gt;add(obj)</code> 方法将对象加入该 hotPage 中</li>
</ul>
</li>
<li>hotPage 满了<ul>
<li>调用 <code>autoreleaseFullPage(obj, page)</code> 方法，该方法会先查找 hotPage 的 child，如果有则将 child page 设置为 hotPage，如果没有则将创建一个新的 hotPage，之后在这个新的 hotPage 上执行 <code>page-&gt;add(obj)</code> 操作</li>
</ul>
</li>
<li>hotPage 不存在<ul>
<li>调用 <code>autoreleaseNoPage(obj)</code> 方法，该方法会创建一个 hotPage，然后执行 <code>page-&gt;add(obj)</code> 操作</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：hotPage 表示正在使用中的 page</p>
</blockquote>
<p>接下来看看 <code>add</code> 方法的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">id *add(id obj)</div><div class="line">&#123;</div><div class="line">    assert(!full());</div><div class="line">    unprotect();</div><div class="line">    id *ret = next;  // faster than `return next-1` because of aliasing</div><div class="line">    *next++ = obj;</div><div class="line">    protect();</div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此方法会把 <code>obj</code> 存放在原本 <code>next</code> 所在的位置，然后 <code>next</code> 指针移到下一个位置。</p>
<p>最后再看下 <code>autorelease</code> 方法，同样也是会调用 <code>autoreleaseFast(obj)</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static inline id autorelease(id obj)</div><div class="line">&#123;</div><div class="line">    assert(obj);</div><div class="line">    assert(!obj-&gt;isTaggedPointer());</div><div class="line">    id *dest __unused = autoreleaseFast(obj);</div><div class="line">    assert(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后小结一下，调用 <code>objc_autoreleasePoolPush</code> 方法时，会先 <code>add</code> 一个 <code>POOL_BOUNDARY</code>，然后向一个对象发送 <code>autorelease</code> 消息，就会把该对象 <code>add</code> 进 page 里。</p>
<h2 id="objc-autoreleasePoolPop"><a href="#objc-autoreleasePoolPop" class="headerlink" title="objc_autoreleasePoolPop"></a>objc_autoreleasePoolPop</h2><p>方法定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void objc_autoreleasePoolPop(void *ctxt)</div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage::pop(ctxt);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>静态方法 <code>pop(ctxt)</code> （其中 <code>ctxt</code> 是前面 <code>push</code> 后返回的哨兵对象）有点长，这里精简一下代码，这方法关键是会调用 <code>releaseUntil</code> 方法去释放对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">static inline void pop(void *token) </div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage  *page = pageForPointer(token);</div><div class="line">    id *stop = (id *)token;</div><div class="line">    </div><div class="line">    page-&gt;releaseUntil(stop);</div><div class="line">    </div><div class="line">    if (page-&gt;child) &#123;</div><div class="line">        // hysteresis: keep one empty child if page is more than half full</div><div class="line">        if (page-&gt;lessThanHalfFull()) &#123;</div><div class="line">            page-&gt;child-&gt;kill();</div><div class="line">        &#125; else if (page-&gt;child-&gt;child) &#123;</div><div class="line">            page-&gt;child-&gt;child-&gt;kill();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>pageForPointer(token)</code> 会获取哨兵对象所在 page：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static AutoreleasePoolPage *pageForPointer(uintptr_t p) </div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage *result;</div><div class="line">    uintptr_t offset = p % SIZE;</div><div class="line"></div><div class="line">    assert(offset &gt;= sizeof(AutoreleasePoolPage));</div><div class="line"></div><div class="line">    result = (AutoreleasePoolPage *)(p - offset);</div><div class="line">    result-&gt;fastcheck();</div><div class="line"></div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要是通过指针与 page 大小取模得到其偏移量（因为所有的 AutoreleasePoolPage 在内存中都是对齐的），最后通过 <code>fastCheck()</code> 方法检查得到的是不是一个 AutoreleasePoolPage。</p>
<p>之后调用 <code>releaseUntil</code> 循环释放对象，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">void releaseUntil(id *stop) </div><div class="line">&#123;</div><div class="line">    while (this-&gt;next != stop) &#123;</div><div class="line">        // Restart from hotPage() every time, in case -release </div><div class="line">        // autoreleased more objects</div><div class="line">        AutoreleasePoolPage *page = hotPage();</div><div class="line"></div><div class="line">        // fixme I think this `while` can be `if`, but I can&apos;t prove it</div><div class="line">        while (page-&gt;empty()) &#123;</div><div class="line">            page = page-&gt;parent;</div><div class="line">            setHotPage(page);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        page-&gt;unprotect();</div><div class="line">        id obj = *--page-&gt;next;</div><div class="line">        memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));</div><div class="line">        page-&gt;protect();</div><div class="line"></div><div class="line">        if (obj != POOL_BOUNDARY) &#123;</div><div class="line">            objc_release(obj);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    setHotPage(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>releaseUntil</code> 方法会先把 <code>next</code> 指针向前移动，取到将要释放的一个指针，之后调用 <code>memset</code> 擦除该指针所占内存，再调用 <code>objc_release</code> 方法释放该指针指向的对象，这样通过 <code>next</code> 指针循环往前查找去释放对象，期间可往前跨越多个 page，直到找到传进来的哨兵对象为止。</p>
<p>当有嵌套的 autoreleasepool 时，会清除一层后再清除另一层，因为 pop 是会释放到上次 push 的位置为止，就像剥洋葱一样，每次一层，互不影响。</p>
<p>最后如果传入的哨兵对象所在 page 有 child，有两种情况：</p>
<ul>
<li>当前 page 使用不满一半，从 child page 开始将后面所有 page 删除</li>
<li>当前 page 使用超过一半，从 child page 的 child page（即孙子，如果有的话）开始将后面所有的 page 删除</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if (page-&gt;child) &#123;</div><div class="line">    // hysteresis: keep one empty child if page is more than half full</div><div class="line">    if (page-&gt;lessThanHalfFull()) &#123;</div><div class="line">        page-&gt;child-&gt;kill();</div><div class="line">    &#125; else if (page-&gt;child-&gt;child) &#123;</div><div class="line">        page-&gt;child-&gt;child-&gt;kill();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于为什么要分这两种情况，猜测可能是以空间换取时间吧，当使用超过一半时，当前 page 可能很快就用完了，所以将 child page 留着，减少创建新 page 的开销。</p>
<p><code>kill()</code> 方法会将后面所有的 page 都删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">void kill() </div><div class="line">&#123;</div><div class="line">    // Not recursive: we don&apos;t want to blow out the stack </div><div class="line">    // if a thread accumulates a stupendous amount of garbage</div><div class="line">    AutoreleasePoolPage *page = this;</div><div class="line">    while (page-&gt;child) page = page-&gt;child;</div><div class="line"></div><div class="line">    AutoreleasePoolPage *deathptr;</div><div class="line">    do &#123;</div><div class="line">        deathptr = page;</div><div class="line">        page = page-&gt;parent;</div><div class="line">        if (page) &#123;</div><div class="line">            page-&gt;unprotect();</div><div class="line">            page-&gt;child = nil;</div><div class="line">            page-&gt;protect();</div><div class="line">        &#125;</div><div class="line">        delete deathptr;</div><div class="line">    &#125; while (deathptr != this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后再总结一下自动释放池的原理，自动释放池是由多个 <code>autorelease page</code> 组成的 <code>双向链表</code>，其中主要通过 push 及 pop 操作来管理：</p>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>自动释放池会先调用 <code>objc_autoreleasePoolPush</code> 函数，这函数首先在当前 <code>next</code> 指向的位置存放一个 <code>POOL_BOUNDARY</code>，然后当向一个对象发送 <code>autorelease</code> 消息时，会在哨兵对象后面插入指向该对象的指针，之后把 <code>next</code> 指向刚插入的位置的下一个内存地址，如图所示：</p>
<p><img src="http://file.arvit.xyz/dd6c093b0b87c86ed7e16c1fe6ad2f0d1489502563.png" alt="image"></p>
<p>当这一页 page 快满时（即 <code>next</code> 即将指向栈顶——end() 位置），说明这一页 page 快满了。这时如果再加入一个对象，会先建立下一页 page，双向链表建立完成后，新的 page 的 <code>next</code> 指向该页的栈底——begin() 位置，之后继续向栈顶添加新的指针。</p>
<h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>调用完前面说的 <code>objc_autoreleasePoolPush</code> 后，会返回一个 <code>POOL_BOUNDARY</code> 的地址，当对象要释放时，会调用 <code>objc_autoreleasePoolPop</code> 函数，将该 <code>POOL_BOUNDARY</code> 作为其入参，然后会执行如下操作：</p>
<ul>
<li>根据传入的 <code>POOL_BOUNDARY</code> （push 后得到的那个）找到其所在的 page；</li>
<li>从 <code>hotPage</code> 的 <code>next</code> 指针开始往前查找，向找到的每个指针调用 <code>memset</code> 方法以擦除指针所占内存，再调用 <code>objc_release</code> 方法释放该指针指向的对象，直到前一步所找到的 page 的 <code>POOL_BOUNDARY</code> 为止（可往前跨越多个 page），并且在释放前，<code>next</code> 指针也会往回指向正确的位置。</li>
</ul>
<p>当有嵌套的 autoreleasepool 时，会清除一层后再清除另一层，因为 pop 是会释放到上次 push 的位置为止，就像剥洋葱一样，每次一层，互不影响。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>一、autorelease 对象会在什么时候释放？</p>
<p>分两种情况：</p>
<ol>
<li>使用 <code>@autoreleasepool</code>，会在大括号结束时释放</li>
<li>不使用 <code>@autoreleasepool</code>，这个会由系统自动释放，释放时机是在当前 <code>runloop</code> 结束时释放，因为系统会自动为每个 <code>runloop</code> 执行自动释放池的 <code>push</code> 和 <code>pop</code> 操作</li>
</ol>
<p>二、关于内存管理的方法，目前来说，有三种：</p>
<ol>
<li>C/C++的完全由程序员管理（paring new/malloc &amp; delete/free）;</li>
<li>Garbage Collection;</li>
<li>Reference Counting;</li>
</ol>
<p>第一种比较原始；Cocoa Touch 的 Reference Counting 对比 Garbage Collection，有一个致命的弱点：无法释放循环引用的对象，所以要注意不要造成循环引用。</p>
<blockquote>
<p>PS: 维基百科上有说 Reference Couting 属于 GC 的一种方式：<br>Reference counting is a form of garbage collection whereby each object has a count of the number of references to it.<br>详见链接：<br><a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science" target="_blank" rel="external">Reference_counting</a>#Reference_counting)</p>
<p>不过也有人说不是，没有定论，这里作一下简单说明。</p>
</blockquote>
<p>三、什么时候应该使用 @autoreleasepool</p>
<p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI" target="_blank" rel="external">苹果的文档</a> 有说了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">If you are writing a program that is not based on a UI framework, such as a command-line tool.  </div><div class="line"></div><div class="line">If you write a loop that creates many temporary objects.</div><div class="line">You may use an autorelease pool block inside the loop to dispose of those objects before the next iteration. Using an autorelease pool block in the loop helps to reduce the maximum memory footprint of the application.</div><div class="line"></div><div class="line">If you spawn a secondary thread.</div><div class="line">You must create your own autorelease pool block as soon as the thread begins executing; otherwise, your application will leak objects. (See Autorelease Pool Blocks and Threads for details.)</div></pre></td></tr></table></figure>
<p>即：</p>
<ol>
<li>你的程序不是基于 UI 框架的，如命令行工具</li>
<li>你编写的循环创建了大量的临时对象</li>
<li>如果你创建了一个辅助线程</li>
</ol>
<p>参考资料：<br><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">黑幕背后的Autorelease</a><br><a href="http://draveness.me/autoreleasepool/" target="_blank" rel="external">自动释放池的前世今生 —- 深入解析 autoreleasepool</a></p>
<hr>
<p>2017-03-12 21:32<br>Aevit<br>深大轻茶馆</p>
<hr>
<p><a class="http://file.arvit.xyz/8a7fb3f261eec1bc75d194981555c7291489325426.jpeg" title="黄姚日出"><img src="http://file.arvit.xyz/8a7fb3f261eec1bc75d194981555c7291489325426.jpeg" alt=""></a><br>摄影：Aevit 2015年8月 黄姚</p>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/比特海/">比特海</a>
            
              <a href="/tags/iOS/">iOS</a>
            
              <a href="/tags/runtime/">runtime</a>
            
              <a href="/tags/autorelease/">autorelease</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2017/03/28/iOS-network-keep-alive/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">NSURLSession错误使用引起的网络阻塞问题</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2017/01/09/iOS-__block/">
        <span class="next-text nav-default">__block修饰符探究</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:aevit@qq.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/aevit" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
        
          <a href="http://www.okayapi.com/?f=aevit" class="iconfont icon-pocket" title="pocket"></a>
        
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Aevit</span>
  </span>

  <div style="width:300px;margin:0 auto; padding:20px 0;">
    <a href="javascript:void(0)" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"><img src="" style="float:left;"/><p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">粤ICP备18142108号</p></a>
  </div>
    
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://aevit.xyz/2017/03/12/iOS-autorelease/';
        this.page.identifier = '2017/03/12/iOS-autorelease/';
        this.page.title = 'iOS 自动释放池原理探究';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//aevit.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  

  



    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.5.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.5.0"></script>

  </body>
</html>
