<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="__block修饰符探究"/>




  <meta name="keywords" content="比特海, iOS, __block, runtime, Arvit" />










  <link rel="alternate" href="/atom.xml" title="Arvit">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.5.0" />



<link rel="canonical" href="http://arvit.xyz/2017/01/09/iOS-__block/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.5.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  
  <script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?27c09d216f39fb173da80070c4219fb8";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> __block修饰符探究 - Arvit </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Arvit</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Arvit</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title-diu-helkyle">
        
          __block修饰符探究
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-01-09
        </span>
        
          <div class="post-category">
            
              <a href="/categories/比特海/">比特海</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#block-的实质"><span class="toc-text">block 的实质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不加-block-修饰符"><span class="toc-text">不加 __block 修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#小结-1"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加-block-修饰符"><span class="toc-text">加 __block 修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分析"><span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#验证"><span class="toc-text">验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说明"><span class="toc-text">说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结-2"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道，在 <code>block</code> 里面能读取外部变量，但是如果需要修改外部变量的值，需要给变量加上 <code>__block</code> 修饰符才行。</p>
<p>接下来让我们带着2个问题来研究一下：</p>
<ol>
<li>为什么不加 <code>__block</code> 就只能读取，不能修改（即：<code>block</code> 的实现，是怎么达到不能修改的）</li>
<li>加了 <code>__block</code> 为什么就能修改</li>
</ol>
<a id="more"></a>
<hr>
<h2 id="block-的实质"><a href="#block-的实质" class="headerlink" title="block 的实质"></a>block 的实质</h2><p>先举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        int valA = 1;</div><div class="line">        __block int valB = 11;</div><div class="line">        void (^block)(void) = ^&#123;</div><div class="line">//            valA = 2;</div><div class="line">            valB = 22;</div><div class="line">            NSLog(@&quot;%d, %d&quot;, valA, valB);</div><div class="line">        &#125;;</div><div class="line">        block();</div><div class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 <code>clang -rewrite-objc</code> 重写后，得到以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_valB_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_valB_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int valB;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int valA;</div><div class="line">  __Block_byref_valB_0 *valB; // by ref</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _valA, __Block_byref_valB_0 *_valB, int flags=0) : valA(_valA), valB(_valB-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_valB_0 *valB = __cself-&gt;valB; // bound by ref</div><div class="line">  int valA = __cself-&gt;valA; // bound by copy</div><div class="line"></div><div class="line"></div><div class="line">            (valB-&gt;__forwarding-&gt;valB) = 22;</div><div class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_6p_1hbzwy3900vd5kkrph4hz29w0000gn_T_main_9fdbf1_mi_0, valA, (valB-&gt;__forwarding-&gt;valB));</div><div class="line">        &#125;</div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;valB, (void*)src-&gt;valB, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;valB, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line"></div><div class="line">        int valA = 1;</div><div class="line">        __attribute__((__blocks__(byref))) __Block_byref_valB_0 valB = &#123;(void*)0,(__Block_byref_valB_0 *)&amp;valB, 0, sizeof(__Block_byref_valB_0), 11&#125;;</div><div class="line">        void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, valA, (__Block_byref_valB_0 *)&amp;valB, 570425344));</div><div class="line">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        return UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;AppDelegate&quot;), sel_registerName(&quot;class&quot;))));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看 <code>main</code> 函数里面的代码：<br><img src="http://file.arvit.xyz/71dc6fd24fd4df90c1a91b2bb7d3b5b01483953745.jpeg" alt="image"></p>
<p>可以看到，<code>block</code> 被转化成了一个 <code>__main_block_impl_0</code> 结构体对象；</p>
<p>上图中，调用该结构体的构造函数时，传入的第一个参数是一个 <code>__main_block_func_0</code> 类型的变量（这个 <code>__main_block_func_0</code> 是最终 <code>block</code> 里要执行的代码）将会由结构体里的 <code>FuncPtr</code> 成员接收，可以看到这是一个 <code>函数指针</code>；</p>
<p>看上图箭头处，之后 <code>调用 block</code> 就是通过这个 <code>函数指针</code> 去调用的，并且也会传入这个结构体对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div></pre></td></tr></table></figure>
<p>以上简单介绍了一下 <code>main</code> 函数里的相关代码，附上该 <code>block</code> 的结构体构成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int valA;</div><div class="line">  __Block_byref_valB_0 *valB; // by ref</div><div class="line">  </div><div class="line">  // 构造函数</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _valA, __Block_byref_valB_0 *_valB, int flags=0) : valA(_valA), valB(_valB-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中结构体成员包括 <code>valA</code> 及 <code>valB</code>，不过 <code>valB</code> 的类型不是 <code>int</code>，这个我们后面会再说到。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>定义 <code>block</code> 后，实质会生成一个结构体对象；调用定义好的 <code>block</code>，实际就是通过这个结构体对象的函数指针（<code>FuncPtr</code>）去找到具体的实现。</p>
<hr>
<h2 id="不加-block-修饰符"><a href="#不加-block-修饰符" class="headerlink" title="不加 __block 修饰符"></a>不加 __block 修饰符</h2><p>让我们先将之前 <code>main</code> 方法里的 <code>valB</code> 去掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int valA = 1;</div><div class="line">void (^block)(void) = ^&#123;</div><div class="line">    NSLog(@&quot;%d&quot;, valA);</div><div class="line">&#125;;</div><div class="line">block();</div></pre></td></tr></table></figure>
<p>首先，让我们看一下转换后的 <code>main 方法相关代码</code>：</p>
<p><img src="http://file.arvit.xyz/05f4245c2d974ef16e6a1adbc36fab9b1484020226.png" alt="image"></p>
<p>可以看到，调用构造函数时，第三个参数是直接使用 <code>valA</code> 的值的。</p>
<p>再看结构体的声明及其 <code>block</code> 里的实现</p>
<p><img src="http://file.arvit.xyz/141de79f08494688cf0ffb0fc3eaca4b1483953997.jpeg" alt="image"></p>
<p>看图中上面的箭头处，构造函数初始化参数时，是直接使用 <code>val</code> 的值；</p>
<p>我们将 <code>block</code> 看做一个函数，看上图中下面的箭头处，<code>valA</code> 在 <code>block 函数</code> 里也有定义，其值跟 <code>外部的 valA</code> 一样；</p>
<p>此时 <code>block 函数</code> 及 <code>main 函数</code> 在内存中的分布大致如下：</p>
<p><img src="http://file.arvit.xyz/909bc774cc7f9dabaec21a300c6329831483955235.jpeg" alt="image"></p>
<p>可以看到，<code>valA</code> 是在不同作用域的，这一点很关键。</p>
<p>这里谨记 <strong>函数调用的内存机制</strong>：</p>
<blockquote>
<p>一个函数有一个函数自己的栈；如果函数和函数之间要共享内存，那这块被共享的内存不能在某一个函数的栈(stack)上，要在堆(heap)上</p>
</blockquote>
<p>虽然在这里直接看转换后的代码， <code>struct</code> 里其实是可以修改内部的 <code>valA</code> 的，但是因为 <code>valA</code> 这个变量名，在内部和外部都存在，作用域是不同的，所以苹果在编译器层面就已经是禁止修改的。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>不加 <code>__block</code> 修饰时，<code>valA</code> 存在于多个不同的栈中，也就是说作用域不同，所以编译器才会禁止修改。</p>
<p>值得一提的是，我们上面举的例子是 <code>基本类型 int</code>，当换成 <code>对象类型</code>（如 <code>NSString</code>）时，转换后是 <code>const</code> 类型的，这是为什么？</p>
<p><img src="http://file.arvit.xyz/48610aa1b83836e1feea9dca0ce1e0db1483956237.png" alt="image"></p>
<blockquote>
<p>因为结构体的构造函数，只是把调用者（如上面的 <code>main函数</code> ）在栈上的 <code>valStr</code> 的 <code>指针地址</code> 传给了被调用者（如上面的 <code>block函数</code>）；</p>
<p>如果不加const，那被调用者完全可能通过这个地址来修改这个捕获的对象的值，这个时候，如果被调用者的栈已经被回收了，那这个修改，就是在修改一处已经被回收的内存的内容，那就可能崩溃了。</p>
<p>PS: 这里为了演示方便，<code>block</code> 的定义跟调用都是写在 <code>main</code> 里。<br>实际上多数情况下，<code>block</code> 是作为参数传递来做回调的；<br>（如在 <code>类 A 的实例方法 B</code> 中调用 <code>block</code>，如果 <code>B 方法</code> 的栈被回收了，这时再修改里面的局部变量就会崩溃了）。</p>
</blockquote>
<p>还值得一提的是，如果修改的是这个指针所 <code>指向的对象的内容</code>，不加 <code>__block</code> 也是可以的，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSMutableString *str = [NSMutableString stringWithString:@&quot;DaGou&quot;];  </div><div class="line">void (^foo)(void) = ^&#123;</div><div class="line">    str.string = @&quot;Aevit&quot;; // 这里修改的是 堆 中的内容  </div><div class="line">&#125;;</div><div class="line">foo();</div></pre></td></tr></table></figure>
<hr>
<h2 id="加-block-修饰符"><a href="#加-block-修饰符" class="headerlink" title="加 __block 修饰符"></a>加 __block 修饰符</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据上面相关说明，因为作用域不同，如果要能修改 <code>block</code> 里的值，有两种方法：</p>
<ol>
<li><p>调用者（如 <code>类 A 的实例方法 B</code>）在调用 <code>block</code> 时，把自己的栈里的 <code>val</code> 的值通过<strong>地址</strong>的方式传进去；</p>
<p>这种情况有一个问题，那就是 <code>block</code> 没办法保证它自己存在的期间，<code>B 方法</code> 也是存在的；也就是说，当 <code>block</code> 跑到一半的时候，<code>B 方法</code> 的栈可能已经不在了；</p>
</li>
<li><p>为了解决第一种带来的这种调用者和被调用者生命周期上的矛盾，于是引入了第二种方案：<br>把参数拷到 <code>heap</code> 上，这样一来，参数的存在与否，就不和调用者（<code>B 方法</code>）的栈的存在与否挂钩了；换言之就算 <code>B 方法</code> 的栈被回收了，这个时候 <code>heap</code> 上的 <code>val</code> 还是存在的。</p>
</li>
</ol>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>为了验证 <code>block</code> 里的 <code>valB</code> 到底是不是在堆里了，可以打印出地址算一下：</p>
<p><img src="http://file.arvit.xyz/acbac0f5084114ab374d66fa403ee2931484039915.png" alt="image"></p>
<p>定义前的地址（<code>16fd77a68</code>）转成十进制： <code>6171359848</code><br>block 内的地址（<code>170220bb8</code>）转成十进制： <code>6176246712</code></p>
<p>由此可知两者地址之间相差：<br><code>(6176246712 - 6171359848) / (1024 * 1024) = 4.66M</code></p>
<p>由于 <code>iOS</code> 里主线程的栈是 <code>1M</code> （非主线程是 <code>512K</code>，<code>OS X</code> 的主线程是 <code>8M</code>）（<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html" target="_blank" rel="external">官方文档</a>），所以<code>定义前</code>是在栈中，<code>block</code> 内及<code>定义后</code>就是在堆内了。</p>
<blockquote>
<p>PS: 还可通过 <code>pthread</code> 相关方法得到栈大小，可参考以下文章：<br><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man3/pthread.3.html" target="_blank" rel="external">苹果官方文档</a><br><a href="http://blog.csdn.net/tennysonsky/article/details/48767415" target="_blank" rel="external">线程堆栈大小的使用介绍</a></p>
</blockquote>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>下面我们结合代码来具体说明一下第二种方案：</p>
<p>现在我们只使用带有 <code>__block</code> 修饰符的 <code>valB</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__block int valB = 11;</div><div class="line">void (^block)(void) = ^&#123;</div><div class="line">    valB = 22;</div><div class="line">    NSLog(@&quot;%d&quot;, valB);</div><div class="line">&#125;;</div><div class="line">block();</div></pre></td></tr></table></figure>
<p>看下图，可以发现 <code>__block int valB = 11</code> 转换成了一个结构体 <code>__Block_byref_valB_0</code>，注意下图中上面的箭头，构造函数里传递的第二个参数是 <code>&amp;valB</code>（即 <code>valB</code> 变量的首地址）：<br><img src="http://file.arvit.xyz/8dd1d76676d2755f77b507351a93f9781484029267.png" alt="image"></p>
<p>再看其它部分代码：<br><img src="http://file.arvit.xyz/609c7734152c10ac49f87302cbbd2d841483965263.jpeg" alt="image"></p>
<p><code>__Block_byref_valB_0</code> 结构体声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_valB_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_valB_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int valB;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到第二个参数是 <code>__Block_byref_valB_0 *__forwarding</code>，而刚才已经说了 <code>main</code> 函数里 <code>valB</code> 的构造函数里传递的第二个参数是 <code>&amp;valB</code>，所以 <code>__forwarding</code> 这是该实例自身的引用，内存结构大致如下：</p>
<p><img src="http://file.arvit.xyz/308cc2d566a87ed0b8c1f12d565a21731484032183.jpeg" alt="image"></p>
<p>根据我们之前的分析，经过 <code>block</code> 后，编译器会将 <code>valB</code> 拷贝至<strong>堆</strong>中，这时内存结构大致如下：</p>
<p><img src="http://file.arvit.xyz/0e1aaf58c44ca69abb63bb77f8dd65981483967160.jpeg" alt="image"></p>
<p>其中栈中（包括 <code>block</code> 及 <code>main</code> ）的 <code>__forwarding</code> 指向堆中 <code>valB 实例</code> 首地址，堆中的 <code>valB 实例</code> 的 <code>__forwarding</code> 指向自身首地址。</p>
<p>再来看一下 <code>block</code> 里的具体代码实现，可以看到代码里已经是对堆里的内容进行修改了（使用 <code>valB-&gt;__forwarding-&gt;valB</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// block 里的具体定义</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    __Block_byref_valB_0 *valB = __cself-&gt;valB; // bound by ref</div><div class="line"></div><div class="line">    (valB-&gt;__forwarding-&gt;valB) = 22; // 修改的是堆里的内容</div><div class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_6p_1hbzwy3900vd5kkrph4hz29w0000gn_T_main_b97c95_mi_0, (valB-&gt;__forwarding-&gt;valB));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以 <code>block</code> 里修改的实际是 <code>堆</code> 里的东西了。</p>
<p>最后还有一个问题，变量是怎样被 <code>copy</code> 到堆里的？</p>
<p>看下图，可以看到 <code>clang -rewrite-objc</code> 后生成的是 <code>_NSConcreteStackBlock</code> 类型的，是存在栈上的，而最终我们打断点会发现类型变成了 <code>_NSConcreteMallocBlock</code> ，这是因为在 <code>ARC</code> 环境下，编译器会自动将 <code>block</code> <code>copy</code> 到堆里，所以变量也会随之 <code>copy</code> 到堆里；如果是 <code>MRC</code> 环境，就需要手动 <code>copy</code> 了。</p>
<p><img src="http://file.arvit.xyz/44793bb2dbf77f118b4a6a9076ffab721484104519.png" alt="image"></p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>加了 <code>__block</code> 后的变量，生成的是一个结构体变量，在经过 <code>block</code> （也就是定义 <code>block</code> ）时，会将该结构体拷贝至<strong>堆</strong>中，栈内的 <code>__forwarding</code> 指向堆中的地址，之后对该变量的操作，实际上是对<strong>堆</strong>里的变量的操作。</p>
<p>另外，该结构体变量的 <code>isa</code> 指针有三种情况：</p>
<ul>
<li><code>_NSConcreteStackBlock</code> 保存在 <code>栈</code> 中的block，出栈时会被销毁</li>
<li><code>_NSConcreteGlobalBlock</code> <code>全局的静态</code> block，不会访问任何外部变量</li>
<li><code>_NSConcreteMallocBlock</code> 保存在 <code>堆</code> 中的block，当引用计数为0时会被销毁</li>
</ul>
<p>上面我们生成的是 <code>_NSConcreteStackBlock</code>，像这样的就是 <code>_NSConcreteGlobalBlock</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void (^block)(void) = ^&#123;NSLog(@&quot;This is a Global Block&quot;);&#125;;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        block();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当使用 <code>copy</code> 操作时，生成的就是 <code>_NSConcreteMallocBlock</code>，并且我们可以看到转换后的代码还有 <code>__main_block_copy_0</code>、<code>__main_block_dispose_0</code> 这两个静态函数。<br>当 <code>block</code> 从栈中拷贝到堆中时，会调用前者持有该变量，当堆上的 <code>block</code> 回收时，会调用后者释放该变量。</p>
<p>以下是 <code>ARC</code> 环境下，<code>block</code> 有无强引用，内部有无使用外部变量生成的类型（测试时间是 <code>2017-01-11</code>）：</p>
<table>
<thead>
<tr>
<th></th>
<th>有强引用</th>
<th>无强引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用外部变量</td>
<td>_NSConcreteMallocBlock</td>
<td>_NSConcreteStackBlock</td>
</tr>
<tr>
<td>无外部变量</td>
<td>_NSConcreteGlobalBlock</td>
<td>_NSConcreteGlobalBlock</td>
</tr>
</tbody>
</table>
<p><img src="http://file.arvit.xyz/4dc76a9bf32d5c181b3a3c8c1537ed4b1484106867.png" alt="image"></p>
<p>即：<br><code>block</code> 内没有使用到外部变量，生成的是 <code>_NSConcreteGlobalBlock</code>；<br>如果有使用外部变量，有强引用的是 <code>_NSConcreteMallocBlock</code>，无强引用的是 <code>_NSConcreteStackBlock</code>；</p>
<p>看完以上三种类型的 <code>block</code> 后，可以做一下这里的 <a href="http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/" target="_blank" rel="external">题目</a> 巩固一下</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这里要非常感谢 <a href="http://weibo.com/u/1527399354" target="_blank" rel="external">@刘煌旭</a> 解答了困扰我多日的一些问题！</p>
<p>这里最后简单说明一下：</p>
<blockquote>
<p>一、不加 <code>__block</code> 为什么不能修改（即苹果是如何让 <code>block</code> 里变量不能修改的）：</p>
</blockquote>
<p>外部的 <code>valA</code> 在 <code>main 的栈</code> 上有一份内存，同时 <code>block 的栈</code> 上也会拷贝 valA 的一份内存；<br>由于函数调用的内存机制，valA 在不同的栈上，作用域不同，所以是不能修改的。<br>并且如果是 <code>对象类型</code> 的，在 <code>block</code> 内部是 <code>const</code> 的，不能修改。</p>
<blockquote>
<p>二、加了 <code>__block</code> 为什么能修改：</p>
</blockquote>
<p>加了 <code>__block</code>，会把变量拷贝到堆里，修改的实际是堆里的内容。</p>
<p>参考资料：<br><a href="http://chun.tips/blog/2014/11/13/hei-mu-bei-hou-de-blockxiu-shi-fu/" target="_blank" rel="external">黑幕背后的__block修饰符</a><br><a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="external">谈Objective-C block的实现</a></p>
<hr>
<p>2017-01-09 21:34<br>Aevit<br>深大轻茶馆</p>
<hr>
<p><a class="http://file.arvit.xyz/1993ab9d9d77c4eabfb9a84b599f149c1483968843.jpeg" title="茶卡盐湖"><img src="http://file.arvit.xyz/1993ab9d9d77c4eabfb9a84b599f149c1483968843.jpeg" alt=""></a><br>摄影：Aevit 2016年8月 茶卡盐湖</p>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/比特海/">比特海</a>
            
              <a href="/tags/iOS/">iOS</a>
            
              <a href="/tags/block/">__block</a>
            
              <a href="/tags/runtime/">runtime</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2017/03/12/iOS-autorelease/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">iOS 自动释放池原理探究</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2016/10/25/iOS-class-cluster/">
        <span class="next-text nav-default">iOS设计模式 —— 类簇</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:aevit@qq.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/aevit" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
        
          <a href="http://www.okayapi.com/?f=aevit" class="iconfont icon-pocket" title="pocket"></a>
        
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Arvit</span>
  </span>

  <div style="width:300px;margin:0 auto; padding:20px 0;">
    <a href="javascript:void(0)" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"><img src="" style="float:left;"/><p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">粤ICP备18142108号</p></a>
  </div>
    
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://arvit.xyz/2017/01/09/iOS-__block/';
        this.page.identifier = '2017/01/09/iOS-__block/';
        this.page.title = '__block修饰符探究';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//aevit.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  

  



    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.5.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.5.0"></script>

  </body>
</html>
